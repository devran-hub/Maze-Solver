#include <NewPing.h>
#include "Wire.h"
#include <MPU6050_light.h>

#define TRIG_PIN_FRONT 5
#define ECHO_PIN_FRONT 4
#define TRIG_PIN_LEFT 12
#define ECHO_PIN_LEFT 13
#define TRIG_PIN_RIGHT 2
#define ECHO_PIN_RIGHT 3

// Motor control pins
#define MOTOR_LEFT_FORWARD 9
#define MOTOR_LEFT_BACKWARD 10
#define MOTOR_RIGHT_FORWARD 7
#define MOTOR_RIGHT_BACKWARD 8
#define ENL 11
#define ENR 6

#define WALL_DISTANCE 15
#define MIN_DISTANCE 2

MPU6050 mpu(Wire);
NewPing sonarFront(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
NewPing sonarLeft(TRIG_PIN_LEFT, ECHO_PIN_LEFT);
NewPing sonarRight(TRIG_PIN_RIGHT, ECHO_PIN_RIGHT);

float angle = 0.0f;

void setup() {
  Serial.begin(9600);
  Wire.begin();
  byte status = mpu.begin();
  while (status != 0) { }
  mpu.calcOffsets();

  pinMode(MOTOR_LEFT_FORWARD, OUTPUT);
  pinMode(MOTOR_LEFT_BACKWARD, OUTPUT);
  pinMode(MOTOR_RIGHT_FORWARD, OUTPUT);
  pinMode(MOTOR_RIGHT_BACKWARD, OUTPUT);
}

void loop() {
  mpu.update();
  angle = mpu.getAngleZ();
  
  analogWrite(ENR, 255);
  analogWrite(ENL, 255);

  int distanceRight = getFilteredDistance(sonarRight);
  int distanceFront = getFilteredDistance(sonarFront);
  int distanceLeft = getFilteredDistance(sonarLeft);

  if (distanceRight > MIN_DISTANCE && distanceRight < WALL_DISTANCE) {
    if (distanceFront > MIN_DISTANCE) {
      moveForwardWithCorrection();  // Jiroskop ile düz git
    } else if (distanceLeft > WALL_DISTANCE) {
      stopRobot();
      turnLeftWithGyro(90);  // 90 derece sola dön
    } else {
      stopRobot();
      turn180WithGyro();  // 180 derece dön
    }
  } else {
    stopRobot();
    turnRightWithGyro(90);  // 90 derece sağa dön
  }
}

// Jiroskop verisi ile düz gitme kontrolü
void moveForwardWithCorrection() {
  float targetAngle = angle;  // Şu anki açıyı hedef olarak belirle
  while (abs(mpu.getAngleZ() - targetAngle) > 1) {  // Açı farkı 2'den büyükse düzelt
    if (mpu.getAngleZ() < targetAngle) {
      // Sağa kaydı, sol motoru hızlandır
      analogWrite(ENL, 255);
      analogWrite(ENR, 0);
    } else {
      // Sola kaydı, sağ motoru hızlandır
      analogWrite(ENL, 0);
      analogWrite(ENR, 255);
    }
    delay(50);  // Kısa gecikme ile kontrollü hareket
  }
  moveForward();
}

// Sensörlere göre robot ileri gider
void moveForward() {
  digitalWrite(MOTOR_LEFT_FORWARD, HIGH);
  digitalWrite(MOTOR_RIGHT_FORWARD, HIGH);
}

void stopRobot() {
  digitalWrite(MOTOR_LEFT_FORWARD, LOW);
  digitalWrite(MOTOR_RIGHT_FORWARD, LOW);
}

// Jiroskop ile 90 derece sola dönme
void turnLeftWithGyro(float targetAngle) {
  float startAngle = angle;
  while (abs(angle - (startAngle - targetAngle)) > 2) {
    digitalWrite(MOTOR_LEFT_BACKWARD, HIGH);
    digitalWrite(MOTOR_RIGHT_FORWARD, HIGH);
    mpu.update();
    angle = mpu.getAngleZ();
  }
  stopRobot();
}

// Jiroskop ile 90 derece sağa dönme
void turnRightWithGyro(float targetAngle) {
  float startAngle = angle;
  while (abs(angle - (startAngle + targetAngle)) > 2) {
    digitalWrite(MOTOR_LEFT_FORWARD, HIGH);
    digitalWrite(MOTOR_RIGHT_BACKWARD, HIGH);
    mpu.update();
    angle = mpu.getAngleZ();
  }
  stopRobot();
}

// Jiroskop ile 180 derece dönme
void turn180WithGyro() {
  float targetAngle = 180;
  turnLeftWithGyro(targetAngle);
}

// Sensörden ortalamalı mesafe ölçme
int getFilteredDistance(NewPing sonar) {
  int totalDistance = 0;
  int readings = 3;
  for (int i = 0; i < readings; i++) {
    int distance = sonar.ping_cm();
    if (distance > MIN_DISTANCE && distance < 400) {
      totalDistance += distance;
    }
    delay(50);
  }
  if (totalDistance > 0) {
    return totalDistance / readings;
  } else {
    return 400;
  }
}
